# How Scout Works

This section delves into the architecture of Scout, its core components, and the typical lifecycle of a self-optimizing AB test managed by the system.

## Core Concepts

Before diving into the architecture, let's recap some key concepts:

*   **Test (Model/Bandit Model):** An individual experiment you're running. For example, testing different headlines for a webpage, or different recommendation algorithms in your app. Each test is powered by its own multi-armed bandit model (`cb_model_id`).
*   **Variants:** The different options you are testing within a single test (e.g., "Headline A", "Headline B", "Headline C"). Each variant has an ID and a label.
*   **Context:** A set of key-value pairs representing situational information when a decision (recommendation) is needed. Examples: `{"user_segment": "new", "device_type": "mobile"}`. Scout uses this context to make personalized decisions if your model is configured for contextual bandits.
*   **Reward:** A numerical value indicating the outcome of showing a particular variant in a given context. For example, a click could be a reward of `1`, no click `0`. Higher rewards are better.
*   **Request ID (`request_id`):** A unique identifier generated by your application when requesting a variant recommendation. This ID is crucial for linking the recommendation (and its context) to a subsequent reward update.
*   **Learning Policy:** The algorithm used by the multi-armed bandit to balance exploration (trying out different variants) and exploitation (serving the best-known variant). Scout uses `mabwiser` library which supports policies like Epsilon Greedy, UCB1, Thompson Sampling, etc. (Currently, Scout defaults to a LinUCB style approach for contextual bandits and Thompson Sampling for non-contextual, though this is an internal detail that may evolve).

## Architecture

Scout is a multi-container application orchestrated by Docker Compose. Here are the main components:

```ascii
+---------------------+      +---------------------+      +---------------------+ 
| User's Application  |----->|        Nginx        |<---->| Frontend (React UI) |
| (Your Code)         |      |   (Reverse Proxy)   |      | (localhost:3000)    |
+---------------------+      +----------^----------+      +----------^----------+
       |                                |                        |
       | (API Calls for recommendation/ |                        | (User interacts with UI)
       |  updates via Nginx proxy)      | (Serves UI files)      |
       |                                |                        |
       |                                | (Proxies API calls)    | (API calls to Backend)
       |                                v                        v
       |      +----------------------------------------------------------+
       |      |                      Backend (FastAPI)                   |
       +----->|                      (localhost:8000)                    |
              +----------------------------------^-----------------------+
                                                 |
                                                 | (R/W Models, Context, Locks, Trails)
                                                 v
                                     +---------------------+ 
                                     |        Redis        |
                                     |    (Data Store)     |
                                     +---------------------+
                                                 ^
                                                 | (Scrapes /metrics endpoint)
                                     +---------------------+ 
                                     |     Prometheus      |
                                     | (Metrics System)    |
                                     | (localhost:9090)    |
                                     +---------------------+
```

**Architectural Components:**

1.  **User's Application (Your Code):**
    *   This is where you integrate Scout to optimize parts of your application.
    *   It communicates with the Scout API (via Nginx) to:
        *   Fetch variant recommendations (`/api/fetch_recommended_variant`).
        *   Report outcomes/rewards (`/api/update_model/{cb_model_id}`).

2.  **Nginx (Reverse Proxy):**
    *   Acts as the entry point for most traffic to Scout.
    *   Serves the static files (HTML, CSS, JavaScript) for the **Frontend (React UI)**.
    *   Routes API requests (e.g., `/api/*`, `/admin/*`) to the appropriate **Backend (FastAPI)** service.

3.  **Frontend (React Application):**
    *   Provides a user-friendly web interface for managing tests, viewing performance metrics, configuring system settings, and viewing logs.
    *   Interacts with the **Backend API** to perform these actions.
    *   Typically accessed at `http://localhost:3000`.

4.  **Backend (FastAPI Application - `app.py`):**
    *   The brain of Scout, containing all the core logic.
    *   Exposes a RESTful API for all operations (test creation, updates, predictions, admin functions).
    *   Manages the lifecycle of multi-armed bandit models (`WrappedMAB` class).
    *   Handles context storage and retrieval using Redis for contextual bandits.
    *   Serializes and persists bandit model objects in Redis.
    *   Manages system and model configurations.
    *   Provides a `/metrics` endpoint for Prometheus scraping.
    *   Typically accessed at `http://localhost:8000` (often proxied by Nginx).

5.  **Redis:**
    *   An in-memory data store with multiple crucial roles:
        *   **Context Caching:** Temporarily stores contextual information provided during a `fetch_recommended_variant` call, linking it via a `request_id` for use in a subsequent `update_model` call.
        *   **Model Storage:** Persists serialized bandit model objects (`WrappedMAB` instances), allowing test state to survive restarts.
        *   **Distributed Locks:** Ensures atomic operations when modifying models, preventing race conditions.
        *   **Request Trails:** Stores data about recent prediction and update requests, used by the UI to display activity and performance trends.

6.  **Prometheus:**
    *   A powerful monitoring and alerting toolkit.
    *   Scrapes metrics exposed by the Backend's `/metrics` endpoint at regular intervals.
    *   These metrics cover API performance (request rates, latency, errors), model activity (predictions, updates, rewards per variant), Redis operations, and more.
    *   Typically accessed at `http://localhost:9090` to view metrics or configure alerts (often used with Grafana for dashboards, though Grafana isn't part of the default Scout `docker-compose.yml`).

## Lifecycle of a Test (Interaction Flow)

Here's a typical sequence of events when using Scout:

1.  **Test Creation (via UI or API):**
    *   You define a new test (e.g., "HomePageCallToAction").
    *   You specify the variants (e.g., Button A: "Sign Up Now", Button B: "Get Started Free").
    *   Scout creates a new `WrappedMAB` model instance, assigns it a unique `cb_model_id`, and stores it in Redis.

2.  **Recommendation Request (Your Application -> Scout API via Nginx):**
    *   A user visits your home page.
    *   Your application code calls `POST /api/fetch_recommended_variant`.
    *   **Payload includes:**
        *   `cb_model_id`: For the "HomePageCallToAction" test.
        *   `context` (optional): e.g., `{"user_type": "subscriber", "time_of_day": "morning"}`.
        *   `request_id`: A unique ID your application generates for this specific request (e.g., a UUID).
    *   **Scout Backend:**
        *   Loads the specified `WrappedMAB` model from Redis.
        *   If context is provided and `request_id` is present, it's stored in Redis against the `request_id` with a TTL (Time To Live).
        *   The model's `predict()` method is called (potentially with the encoded context) to select a variant based on its learning policy.
        *   The chosen `variant_id` and its `label` are returned to your application, along with the original `request_id`.

3.  **Variant Display (Your Application):**
    *   Your application receives the recommendation (e.g., Button B: "Get Started Free").
    *   It renders this button for the user.

4.  **Reward Reporting (Your Application -> Scout API via Nginx):**
    *   The user interacts (or doesn't) with the button. Let's say they click it (a positive outcome).
    *   Your application code calls `POST /api/update_model/{cb_model_id}`.
    *   **Payload includes:**
        *   An `updates` array, with at least one update object containing:
            *   `request_id`: The *same* `request_id` from the recommendation step. This is crucial if `context_used_for_prediction` is true.
            *   `variant_id`: The ID of the variant that was actually shown.
            *   `reward`: The outcome (e.g., `1` for a click, `0` for no click within a timeframe).
            *   `context_used_for_prediction`: Set to `true` if this update corresponds to a prediction made *with* context that Scout should retrieve using the `request_id`.
    *   **Scout Backend:**
        *   Acquires a lock for the `cb_model_id`.
        *   Loads the `WrappedMAB` model from Redis.
        *   For each update:
            *   If `context_used_for_prediction` is true and `request_id` is valid, Scout retrieves the original context from Redis.
            *   The model's `partial_fit()` method is called with the variant, reward, and (if applicable) the encoded context.
            *   The context entry for the `request_id` is deleted from Redis.
        *   The updated model is saved back to Redis.
        *   The lock is released.

5.  **Continuous Optimization:**
    *   Steps 2-4 repeat for every user interaction (or batch of interactions).
    *   The bandit model continuously refines its understanding of which variants perform best, possibly under different contexts.
    *   Over time, the system automatically favors higher-performing variants, maximizing your desired outcomes.

6.  **Monitoring and Management (via UI or API):**
    *   You can use the Scout UI or API to:
        *   View lists of active tests and their basic stats.
        *   See detailed performance metrics for a specific test.
        *   Deactivate or delete tests.
        *   Manage API protection and tokens.
        *   Monitor system health and logs (UI log streaming, Prometheus metrics).

This lifecycle allows for dynamic, real-time optimization that adapts to incoming data, making Scout a powerful tool for developers. 